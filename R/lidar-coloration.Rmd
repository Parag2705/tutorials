---
title: "Coloring lidar point clouds with RGB imagery in R"
author: "Max Joseph"
date: "June 30, 2016"
output:
  html_document:
    keep_md: true
---

# Acquire lidar and RGB data from NEON

We will use some sample data provided by the National Ecological Observatory Network Airborne Observation Platform (NEON AOP), available [here](http://www.neonscience.org/data-resources/get-data/airborne-data). 

```{r test-bash, results='hide'}
library(rLiDAR)
library(threejs)
library(raster)

# download data if necessary
neon_dir <- list.files(getwd(), pattern = 'NEON_AOP_sample_data')
if (length(neon_dir) == 0) {
  system("wget http://neonhighered.org/AOPSampleData/AOP_sample_data.zip")
  system("unzip AOP_sample_data.zip && rm AOP_sample_data.zip")
}
```

# Load lidar point cloud and visualize

```{r load-lidar}
gen_lidar_path <- function() {
  sample_dir <- list.files(getwd(), pattern = 'NEON_AOP_sample_data')
  lidar_dir <- 'LiDAR'
  type <- 'Discrete_LiDAR'
  which_lidar <- 'Point_Cloud'
  filename <- '2013_SJER_AOP_point_cloud_unclassified.las'
  file.path(sample_dir, lidar_dir, type, which_lidar, filename)
}

path_to_lidar <- gen_lidar_path()
lidar_d <- readLAS(path_to_lidar)
str(lidar_d)
```

# Load RGB imagery and visualize

```{r load-rgb}
gen_rgb_path <- function() {
  sample_dir <- list.files(getwd(), pattern = 'NEON_AOP_sample_data')
  rgb_dir <- 'RGB_Camera'
  filename <- '2013_SJER_AOP_Camera_sample.tif'
  file.path(sample_dir, rgb_dir, filename)
}

path_to_rgb <- gen_rgb_path()
rgb_image <- stack(path_to_rgb)
plotRGB(rgb_image)
```

# Combine lidar with RGB imagery

To link the lidar data to the RGB image, the coordinate systems must match (this requirement is satisfied in the NEON data).
Below, we use subsampling to avoid creating huge files for this demo.

```{r plot-rgb-cloud}
quantile_subset <- function(vals, q1, q2) {
  # are values between lower (q1) and upper (q2) quantiles?
  qvals <- quantile(vals, c(q1, q2))
  vals > qvals[1] & vals < qvals[2]
}

x_keep <- quantile_subset(lidar_d[, 'X'], .8, 1)
y_keep <- quantile_subset(lidar_d[, 'Y'], 0, .15)
lidar_subset <- lidar_d[x_keep & y_keep, ]
```

Next, we use the `raster::extract()` function to extract the intensities of the R, G, and B bands in our RasterStack `rgb_image` at the X and Y coordinates of our lidar data subset.
We use these values to create a vector of rgb colors, which we use to color our lidar point cloud. 

```{r}
rgb_vals <- extract(rgb_image, lidar_subset[, c('X', 'Y')])
color_vector <- rgb(red = rgb_vals[, 1], 
                    green = rgb_vals[, 2], 
                    blue = rgb_vals[, 3], 
                    maxColorValue = 255)

get_range <- function(x) {
  r_x <- range(x)
  r_x[2] - r_x[1]
}

range_x <- get_range(lidar_subset[, 'X'])
range_y <- get_range(lidar_subset[, 'Y'])
max_range <- max(range_x, range_y)

scatterplot3js(lidar_subset[, 1:3], color = color_vector, 
               renderer = 'canvas', size = .3, 
               xlim = c(min(lidar_subset[, 'X']), min(lidar_subset[, 'X']) + max_range), 
               ylim = c(min(lidar_subset[, 'Y']), min(lidar_subset[, 'Y']) + max_range), 
               zlim = c(min(lidar_subset[, 'Z']), min(lidar_subset[, 'Z']) + max_range))
```

ssdds

-s
-s
-s
-s
-s
-s
-s


## h2


## h2
